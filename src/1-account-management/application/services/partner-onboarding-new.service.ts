import { Injectable, BadRequestException, ConflictException, Logger } from '@nestjs/common';
import { SolicitacaoParceiro } from '../../domain/entities/solicitacao-parceiro.entity';
import { SolicitacaoParceiroRepository } from '../../infrastructure/repositories/solicitacao-parceiro.repository';
import { SolicitacaoLojistaDto } from '../../api/dto/solicitacao-lojista.dto';
import { SolicitacaoEntregadorDto } from '../../api/dto/solicitacao-entregador.dto';
import { SolicitacaoRecebidaEvent } from '../../domain/events/solicitacao-recebida.event';
import { EventBusService } from '../../../common/event-bus';

@Injectable()
export class PartnerOnboardingService {
  private readonly logger = new Logger(PartnerOnboardingService.name);

  constructor(
    private readonly solicitacaoRepository: SolicitacaoParceiroRepository,
    private readonly eventBusService: EventBusService,
  ) {}

  /**
   * Cria uma solicita√ß√£o de parceria para lojista
   */
  async criarSolicitacaoLojista(dados: SolicitacaoLojistaDto): Promise<SolicitacaoParceiro> {
    try {
      this.logger.log(`üè™ Recebendo solicita√ß√£o de lojista: ${dados.email}`);

      // Validar duplicidade
      await this.validarDuplicidade(dados.email);

      // Criar entidade de solicita√ß√£o simplificada
      const solicitacao = this.solicitacaoRepository.create({
        email: dados.email,
        tipo: 'LOJISTA',
        status: 'PENDENTE',
        dados: dados // Armazenar todos os dados como JSON
      });

      // Salvar solicita√ß√£o
      const solicitacaoSalva = await this.solicitacaoRepository.save(solicitacao);

      // Disparar evento
      const evento: SolicitacaoRecebidaEvent = {
        solicitacaoId: solicitacaoSalva.id,
        tipo: 'LOJISTA',
        nome: dados.nome,
        email: dados.email,
        telefone: dados.telefone,
        cpf: dados.cpf,
        timestamp: new Date(),
      };

      this.eventBusService.publish('solicitacao.recebida', evento);

      this.logger.log(`‚úÖ Solicita√ß√£o de lojista criada: ${solicitacaoSalva.id}`);
      return solicitacaoSalva;

    } catch (err) {
      this.logger.error('Erro ao criar solicita√ß√£o de lojista', err);
      throw new BadRequestException('Erro ao processar solicita√ß√£o: ' + err.message);
    }
  }

  /**
   * Cria uma solicita√ß√£o de parceria para entregador
   */
  async criarSolicitacaoEntregador(dados: SolicitacaoEntregadorDto): Promise<SolicitacaoParceiro> {
    try {
      this.logger.log(`üõµ Recebendo solicita√ß√£o de entregador: ${dados.email}`);

      // Validar duplicidade
      await this.validarDuplicidade(dados.email);

      // Criar entidade de solicita√ß√£o simplificada
      const solicitacao = this.solicitacaoRepository.create({
        email: dados.email,
        tipo: 'ENTREGADOR',
        status: 'PENDENTE',
        dados: dados // Armazenar todos os dados como JSON
      });

      // Salvar solicita√ß√£o
      const solicitacaoSalva = await this.solicitacaoRepository.save(solicitacao);

      // Disparar evento
      const evento: SolicitacaoRecebidaEvent = {
        solicitacaoId: solicitacaoSalva.id,
        tipo: 'ENTREGADOR',
        nome: dados.nome,
        email: dados.email,
        telefone: dados.telefone,
        cpf: dados.cpf,
        timestamp: new Date(),
      };

      this.eventBusService.publish('solicitacao.recebida', evento);

      this.logger.log(`‚úÖ Solicita√ß√£o de entregador criada: ${solicitacaoSalva.id}`);
      return solicitacaoSalva;

    } catch (err) {
      this.logger.error('Erro ao criar solicita√ß√£o de entregador', err);
      throw new BadRequestException('Erro ao processar solicita√ß√£o: ' + err.message);
    }
  }

  private async validarDuplicidade(email: string): Promise<void> {
    const solicitacaoExistente = await this.solicitacaoRepository.findOne({ 
      where: { email } 
    });
    
    if (solicitacaoExistente) {
      throw new ConflictException('J√° existe uma solicita√ß√£o com este e-mail');
    }
  }

  /**
   * Busca solicita√ß√µes por status
   */
  async buscarSolicitacoesPorStatus(status: string): Promise<SolicitacaoParceiro[]> {
    return this.solicitacaoRepository.buscarPorStatus(status);
  }

  /**
   * Busca estat√≠sticas de solicita√ß√µes
   */
  async obterEstatisticas(): Promise<any> {
    const [totalLojistas, totalEntregadores] = await Promise.all([
      this.solicitacaoRepository.contarPorTipo('LOJISTA'),
      this.solicitacaoRepository.contarPorTipo('ENTREGADOR'),
    ]);

    return {
      totalLojistas,
      totalEntregadores,
      total: totalLojistas + totalEntregadores
    };
  }
}
